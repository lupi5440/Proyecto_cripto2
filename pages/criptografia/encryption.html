<section id="encryption" class="page">
    <h2>Algoritmos de cifrado modernos</h2>
    <p class="page-description">Los algoritmos de cifrado protegen la confidencialidad de los datos.
        Aprende sobre los est√°ndares modernos m√°s utilizados en la industria.</p>

    <!-- AES -->
    <div class="demo-section algorithm-expanded">
        <h3>AES - Advanced Encryption Standard</h3>

        <div class="algo-info">
            <h4>üìú Historia</h4>
            <p>En 1997, el NIST (National Institute of Standards and Technology) convoc√≥ una competencia p√∫blica
                para reemplazar
                al obsoleto DES. De 15 candidatos, el algoritmo <strong>Rijndael</strong> (creado por los belgas
                Joan Daemen y
                Vincent Rijmen) gan√≥ en 2000 y se convirti√≥ en <strong>AES</strong> en 2001 [1,2,7].</p>
            <ul>
                <li><strong>1997:</strong> NIST anuncia competencia para reemplazar DES</li>
                <li><strong>1998:</strong> 15 algoritmos candidatos presentados</li>
                <li><strong>2000:</strong> Rijndael es seleccionado como ganador</li>
                <li><strong>2001:</strong> Publicado como est√°ndar federal FIPS 197</li>
                <li><strong>Presente:</strong> Usado globalmente en WiFi (WPA2/WPA3), HTTPS (TLS), VPNs, cifrado de
                    disco</li>
            </ul>

            <h4>‚öôÔ∏è Funcionamiento interno</h4>
            <p>AES es un <strong>cifrado de bloque</strong> que opera en bloques de <strong>128 bits (16
                    bytes)</strong>
                usando claves de 128, 192 o 256 bits [7]. El proceso consiste en m√∫ltiples rondas de transformaciones:
            </p>

            <div class="internal-process">
                <h5>Estructura de rondas:</h5>
                <ul>
                    <li><strong>AES-128:</strong> 10 rondas</li>
                    <li><strong>AES-192:</strong> 12 rondas</li>
                    <li><strong>AES-256:</strong> 14 rondas</li>
                </ul>

                <h5>Operaciones en cada ronda [7]:</h5>
                <ol>
                    <li><strong>SubBytes:</strong> Sustituci√≥n no lineal usando tabla S-box (confusi√≥n)
                        <div class="code-example">
                            <pre>Cada byte se reemplaza por otro seg√∫n tabla predefinida
Ejemplo: 0x53 ‚Üí 0xED (S-box lookup)
Rompe patrones estad√≠sticos del texto plano</pre>
                        </div>
                    </li>
                    <li><strong>ShiftRows:</strong> Desplazamiento circular de filas (difusi√≥n)
                        <div class="code-example">
                            <pre>Matriz 4√ó4 de bytes:
Fila 0: no se mueve
Fila 1: shift 1 posici√≥n izquierda
Fila 2: shift 2 posiciones
Fila 3: shift 3 posiciones
Mezcla datos entre columnas</pre>
                        </div>
                    </li>
                    <li><strong>MixColumns:</strong> Transformaci√≥n lineal (difusi√≥n adicional)
                        <div class="code-example">
                            <pre>Multiplicaci√≥n de matriz en GF(2^8)
Mezcla bytes dentro de cada columna
Un bit cambiado afecta toda la columna</pre>
                        </div>
                    </li>
                    <li><strong>AddRoundKey:</strong> XOR con subclave derivada
                        <div class="code-example">
                            <pre>Estado XOR con clave de ronda
Clave expandida genera subclave √∫nica por ronda
Provee la seguridad real del algoritmo</pre>
                        </div>
                    </li>
                </ol>

                <div class="code-example">
                    <strong>Flujo completo AES-128:</strong>
                    <pre>
Texto plano (128 bits)
    ‚Üì
AddRoundKey (ronda inicial con clave)
    ‚Üì
‚îå‚îÄ Rondas 1-9 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  SubBytes                 ‚îÇ
‚îÇ  ShiftRows                ‚îÇ
‚îÇ  MixColumns               ‚îÇ
‚îÇ  AddRoundKey              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚Üì
Ronda final (sin MixColumns)
  SubBytes
  ShiftRows
  AddRoundKey
    ‚Üì
Texto cifrado (128 bits)
</pre>
                </div>
            </div>

            <h4>Modos de operaci√≥n</h4>
            <p>AES cifra bloques de 128 bits. Para mensajes m√°s largos, se usan <strong>modos de operaci√≥n
                    [7,8]</strong>:
            </p>

            <div class="modes-grid">
                <div class="mode-card">
                    <h5>ECB - Electronic Codebook [8]</h5>
                    <p><strong>‚ö†Ô∏è INSEGURO - No usar</strong></p>
                    <div class="code-example">
                        <pre>Cada bloque se cifra independientemente
Bloque 1 ‚Üí AES ‚Üí Cifrado 1
Bloque 2 ‚Üí AES ‚Üí Cifrado 2

‚ùå Problema: Bloques id√©nticos ‚Üí cifrados id√©nticos
‚ùå Revela patrones (ejemplo: imagen ECB conserva forma)
‚ùå Vulnerable a reordenamiento de bloques</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>CBC - Cipher Block Chaining [8]</h5>
                    <p><strong>‚úÖ Seguro con IV √∫nico</strong></p>
                    <div class="code-example">
                        <pre>Cada bloque se XOR con el anterior antes de cifrar
IV (random) XOR Bloque 1 ‚Üí AES ‚Üí Cifrado 1
Cifrado 1  XOR Bloque 2 ‚Üí AES ‚Üí Cifrado 2

‚úÖ Bloques id√©nticos ‚Üí cifrados diferentes
‚úÖ No revela patrones
‚ö†Ô∏è Requiere IV aleatorio √∫nico por mensaje
‚ö†Ô∏è Cifrado secuencial (no paralelizable)
‚ö†Ô∏è Necesita padding (ej: PKCS#7)

Uso: Cifrado de archivos, TLS 1.0-1.2</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>CTR - Counter [8]</h5>
                    <p><strong>‚úÖ Seguro, paralelizable</strong></p>
                    <div class="code-example">
                        <pre>Convierte cifrado de bloque en cifrado de flujo
Contador 1 ‚Üí AES ‚Üí XOR con Bloque 1 ‚Üí Cifrado 1
Contador 2 ‚Üí AES ‚Üí XOR con Bloque 2 ‚Üí Cifrado 2

‚úÖ Paralelizable (r√°pido en multin√∫cleo)
‚úÖ No requiere padding
‚úÖ Acceso aleatorio (descifrar bloque espec√≠fico)
‚ö†Ô∏è Contador NUNCA debe repetirse con misma clave

Uso: Discos cifrados, IPsec, SSH</pre>
                    </div>
                </div>

                <div class="mode-card" style="border-color: #4caf50; background: #f1f8f4;">
                    <h5>GCM - Galois/Counter Mode [8]</h5>
                    <p><strong>‚úÖ‚úÖ RECOMENDADO - Autenticado</strong></p>
                    <div class="code-example">
                        <pre>CTR + autenticaci√≥n GMAC (Galois MAC)

Proporciona:
‚úÖ Confidencialidad (cifrado CTR)
‚úÖ Autenticaci√≥n (detecta modificaciones)
‚úÖ Integridad (tag de 128 bits)
‚úÖ Paralelizable (muy r√°pido)
‚úÖ No requiere padding
‚úÖ Datos adicionales autenticados (AAD)

Salida: Cifrado + Authentication Tag
Verificaci√≥n: Si alguien modifica 1 bit ‚Üí tag falla

Uso: TLS 1.3, WPA3, HTTPS moderno, SSH
Ejemplo: AES-256-GCM (est√°ndar actual)</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>XTS - XEX Tweakable Block Cipher [8]</h5>
                    <p><strong>‚úÖ Especializado para discos</strong></p>
                    <div class="code-example">
                        <pre>Dise√±ado para cifrado de disco completo

Caracter√≠sticas:
‚úÖ Cifra sectores de disco independientemente
‚úÖ Tweak √∫nico por sector (n√∫mero de sector)
‚úÖ No expansi√≥n de datos (sector 512B ‚Üí 512B)
‚úÖ Resistente a ataques de copia/movimiento

‚ö†Ô∏è Solo confidencialidad (no autenticaci√≥n)

Uso: BitLocker, FileVault, dm-crypt, VeraCrypt</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>Otros modos [8]</h5>
                    <ul>
                        <li><strong>CFB/OFB:</strong> Modos de flujo legacy, reemplazados por CTR</li>
                        <li><strong>CCM:</strong> Autenticado (alternativa a GCM), usado en WPA2</li>
                        <li><strong>OCB:</strong> Autenticado, patentado (menos usado)</li>
                        <li><strong>SIV:</strong> Resistente a nonce reutilizado (casos especiales)</li>
                    </ul>
                </div>
            </div>

            <div class="best-practices">
                <h4>üõ°Ô∏è Mejores pr√°cticas AES [7]</h4>
                <ul>
                    <li>‚úÖ Usa <strong>AES-256-GCM</strong> para nuevos proyectos</li>
                    <li>‚úÖ Genera IV/nonce <strong>aleatorio √∫nico</strong> por mensaje (12 bytes para GCM)</li>
                    <li>‚úÖ Nunca reutilices IV/nonce con la misma clave</li>
                    <li>‚úÖ Usa bibliotecas probadas (OpenSSL, libsodium, Web Crypto API)</li>
                    <li>‚úÖ Deriva claves con PBKDF2/Argon2 si usas contrase√±as</li>
                    <li>‚úÖ Almacena IV con el cifrado (no es secreto)</li>
                    <li>‚ùå Nunca uses ECB</li>
                    <li>‚ùå No implementes tu propio AES (usa hardware AES-NI si est√° disponible)</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- RSA -->
    <div class="demo-section algorithm-expanded">
        <h3>RSA - Rivest-Shamir-Adleman [10]</h3>

        <div class="algo-info">
            <h4>üìú Historia</h4>
            <p>En 1977, Ron <strong>R</strong>ivest, Adi <strong>S</strong>hamir y Leonard <strong>A</strong>dleman
                del MIT publicaron el primer sistema pr√°ctico de criptograf√≠a de clave p√∫blica, revolucionando la
                seguridad digital [1,2].</p>
            <ul>
                <li><strong>1976:</strong> Diffie-Hellman publican concepto de criptograf√≠a de clave p√∫blica</li>
                <li><strong>1977:</strong> RSA es inventado como primer sistema pr√°ctico</li>
                <li><strong>1983:</strong> Fundaci√≥n de RSA Security Inc.</li>
                <li><strong>1997:</strong> Patente de RSA expira (ahora es de dominio p√∫blico)</li>
                <li><strong>2000:</strong> RSA vence premio de $200,000 por factorizar RSA-576</li>
                <li><strong>Presente:</strong> Usado en HTTPS, email cifrado (PGP), SSH, firmas digitales</li>
            </ul>

            <h4>‚öôÔ∏è Funcionamiento interno</h4>
            <p>RSA se basa en la <strong>factorizaci√≥n de n√∫meros primos grandes</strong>. Es f√°cil multiplicar dos
                primos enormes,
                pero extremadamente dif√≠cil factorizar el resultado [1.2,9,10].</p>

            <div class="internal-process">
                <h5>Generaci√≥n de claves:</h5>
                <ol>
                    <li><strong>Seleccionar dos primos grandes:</strong>
                        <div class="code-example">
                            <pre>p = 61 (en realidad, ~300 d√≠gitos)
q = 53 (en realidad, ~300 d√≠gitos)

Estos deben ser secretos y aleatorios</pre>
                        </div>
                    </li>
                    <li><strong>Calcular n = p √ó q:</strong>
                        <div class="code-example">
                            <pre>n = 61 √ó 53 = 3233

n es el m√≥dulo (parte p√∫blica)
Para RSA-2048: n tiene 2048 bits (~617 d√≠gitos)</pre>
                        </div>
                    </li>
                    <li><strong>Calcular œÜ(n) = (p-1) √ó (q-1):</strong>
                        <div class="code-example">
                            <pre>œÜ(n) = 60 √ó 52 = 3120

œÜ(n) es la funci√≥n totient de Euler (secreto)</pre>
                        </div>
                    </li>
                    <li><strong>Elegir exponente p√∫blico e:</strong>
                        <div class="code-example">
                            <pre>e = 65537 (valor com√∫n: 2^16 + 1)

Debe cumplir: 1 < e < œÜ(n) y gcd(e, œÜ(n)) = 1
65537 es popular: solo dos 1's en binario (r√°pido)</pre>
                        </div>
                    </li>
                    <li><strong>Calcular exponente privado d:</strong>
                        <div class="code-example">
                            <pre>d √ó e ‚â° 1 (mod œÜ(n))
d = e^(-1) mod œÜ(n)

Usando algoritmo extendido de Euclides
Para nuestro ejemplo: d = 2753

d es el secreto m√°s importante (NUNCA compartir)</pre>
                        </div>
                    </li>
                </ol>

                <h5>Claves resultantes:</h5>
                <div class="code-example">
                    <pre><strong>Clave p√∫blica:</strong>  (e, n) = (65537, 3233)
  ‚Üí Se distribuye libremente
  ‚Üí Usada por cualquiera para CIFRAR mensajes
  ‚Üí Usada para VERIFICAR firmas

<strong>Clave privada:</strong> (d, n) = (2753, 3233)
  ‚Üí Mantenida en secreto absoluto
  ‚Üí Usada para DESCIFRAR mensajes
  ‚Üí Usada para CREAR firmas</pre>
                </div>

                <h5>Cifrado y descifrado:</h5>
                <div class="code-example">
                    <pre><strong>Cifrado (con clave p√∫blica):</strong>
Mensaje m = 123 (debe ser m < n)
Cifrado c = m^e mod n
c = 123^65537 mod 3233 = 855

<strong>Descifrado (con clave privada):</strong>
Mensaje m = c^d mod n
m = 855^2753 mod 3233 = 123 ‚úÖ

<strong>Matem√°tica:</strong>
(m^e)^d ‚â° m (mod n)  ‚Üê Teorema de Euler</pre>
                </div>

                <h5>Firmas digitales:</h5>
                <div class="code-example">
                    <pre><strong>Firmar (con clave privada):</strong>
Hash del documento h = SHA-256(documento)
Firma s = h^d mod n

<strong>Verificar (con clave p√∫blica):</strong>
h_verificado = s^e mod n
Compara: h_verificado == SHA-256(documento)

Si coinciden: ‚úÖ Documento aut√©ntico y no modificado
Si no coinciden: ‚ùå Documento alterado o firma falsa</pre>
                </div>
            </div>

            <!-- RSA interactivo para usuarios -->
            <h3>RSA Interactivo</h3>
            <div class="algo-info">
                <h4>1. Generar claves de Bob</h4>
                <p>Introduce dos primos para Bob (p, q) y un exponente p√∫blico e (3 ‚â§ e ‚â§ 65537). Se calcular√° n, œÜ(n)
                    y la clave privada d usando el algoritmo extendido de Euclides.</p>
                <div class="mode-card" style="padding: 12px; margin-top: 12px;">
                    <div style="display: grid; gap: 8px; grid-template-columns: 1fr 1fr;">
                        <label>
                            Primo p (Bob):
                            <input type="text" id="bob-p" value="61" />
                        </label>
                        <label>
                            Primo q (Bob):
                            <input type="text" id="bob-q" value="53" />
                        </label>
                    </div>
                    <div style="margin-top: 12px; display:flex; gap:8px; align-items:center;">
                        <button id="bob-generate" class="btn-attack" style="background:#1687a7;"
                            onclick="generarLlaves()">Generar clave privada</button>
                    </div>
                    <div id="keyResults" style="display:none; margin-top:15px;">
                        <p><strong>C√°lculos Internos:</strong></p>
                        <ul>
                            <li>M√≥dulo (n) = <span id="displayN" class="math"></span></li>
                            <li>Phi (œÜ) = <span id="displayPhi" class="math"></span></li>
                        </ul>
                        <hr>
                        <p><strong>Llave P√∫blica (e, n):</strong> (<span id="pubE"></span>, <span id="pubN"></span>)
                            <br>
                            <em>(Esta se la damos a Alice)</em>
                        </p>

                        <p><strong>Llave Privada (d):</strong> <span id="privD" class="math"
                                style="background: #ffffcc; padding: 2px;"></span> <br>
                            <em>(Esta la guarda Bob)</em>
                        </p>
                    </div>
                </div>

                <h4>2. Cifrar mensaje de Alice</h4>
                <p>En este apartado, el mensaje de Alice se cifrar√° usando la clave p√∫blica de Bob.</p>
                <small>F√≥rmula aplicada: <code>C = (ASCII ^ e) % n</code></small>
                <div class="mode-card" style="padding: 12px; margin-top: 12px;">
                    <label>
                        Escribe un mensaje corto para enviar a Bob:
                        <input type="text" id="msg-alice" placeholder="Ej: Hola Bob" />
                    </label>
                    <div style="margin-top: 12px; display:flex; gap:8px; align-items:center;">
                        <button id="alice-cifrar" class="btn-attack" style="background:#1687a7;"
                            onclick="cifrarMensaje()">Cifrar con llave p√∫blica</button>
                    </div>
                    <div id="alice-msg-cifrado" class="code-example"
                        style="margin-top: 12px; white-space: pre-wrap; font-family: monospace;"></div>
                </div>

                <h4>3. Descifrar mensaje para Bob</h4>
                <p>Ahora, el mensaje cifrado se descifrar√° usando la clave privada de Bob, para que Bob pueda leerlo.
                </p>
                <small>F√≥rmula aplicada: <code>M = (C ^ d) % n</code></small>
                <div class="mode-card" style="padding: 12px; margin-top: 12px;">
                    <div style="margin-top: 12px; display:flex; gap:8px; align-items:center;">
                        <button id="bob-descifrar" class="btn-attack" style="background:#1687a7;"
                            onclick="descifrarMensaje()">Descifrar con llave privada</button>
                    </div>
                    <div id="bob-msg-descifrado" class="code-example"
                        style="margin-top: 12px; white-space: pre-wrap; font-family: monospace;"></div>
                </div>
            </div>

            <h4>Modos y variantes</h4>
            <p>RSA puro es vulnerable a varios ataques. Se usan esquemas de padding seguros [9,10]:</p>

            <div class="modes-grid">
                <div class="mode-card">
                    <h5>RSA Textbook (Puro) [1,2,10]</h5>
                    <p><strong>‚ö†Ô∏è INSEGURO - No usar</strong></p>
                    <div class="code-example">
                        <pre>c = m^e mod n

‚ùå Determin√≠stico: mismo mensaje ‚Üí mismo cifrado
‚ùå Vulnerable a ataques matem√°ticos
‚ùå Multiplicaci√≥n: c1√óc2 = (m1√óm2)^e mod n
‚ùå Solo educativo, NUNCA en producci√≥n</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>PKCS#1 v1.5 Padding [1,2,10]</h5>
                    <p><strong>‚ö†Ô∏è Legacy - Siendo reemplazado</strong></p>
                    <div class="code-example">
                        <pre>Formato: 0x00 || 0x02 || padding || 0x00 || mensaje

‚úÖ Agrega aleatoriedad (no determin√≠stico)
‚ö†Ô∏è Vulnerable a ataque Bleichenbacher (1998)
‚ö†Ô∏è Timing attacks posibles
‚ö†Ô∏è A√∫n usado en TLS 1.2 y SSL (por compatibilidad)

Uso: Legacy, reemplazar con OAEP</pre>
                    </div>
                </div>

                <div class="mode-card" style="border-color: #4caf50; background: #f1f8f4;">
                    <h5>OAEP - Optimal Asymmetric Encryption Padding [1,2,10]</h5>
                    <p><strong>‚úÖ‚úÖ RECOMENDADO para cifrado</strong></p>
                    <div class="code-example">
                        <pre>RSA-OAEP = RSA + OAEP padding (PKCS#1 v2.1)

Proceso:
1. Hash del mensaje
2. M√°scara de generaci√≥n de funci√≥n (MGF1)
3. XOR con valores aleatorios
4. RSA sobre resultado

‚úÖ Probabil√≠stico (aleatoriedad en cada cifrado)
‚úÖ Resistente a ataques conocidos
‚úÖ Seguridad demostrable (modelo Random Oracle)
‚úÖ IND-CCA2 seguro (m√°xima seguridad te√≥rica)

Par√°metros: RSA-OAEP-SHA256
Uso: Est√°ndar actual, PKCS#11, OpenSSL default</pre>
                    </div>
                </div>

                <div class="mode-card" style="border-color: #4caf50; background: #f1f8f4;">
                    <h5>PSS - Probabilistic Signature Scheme [1,2,10]</h5>
                    <p><strong>‚úÖ‚úÖ RECOMENDADO para firmas</strong></p>
                    <div class="code-example">
                        <pre>RSA-PSS = RSA + PSS padding (PKCS#1 v2.1)

Proceso:
1. Hash del mensaje (ej: SHA-256)
2. Salt aleatorio de 32 bytes
3. MGF1 para m√°scara
4. Padding estructurado
5. RSA sobre resultado

‚úÖ Probabil√≠stico (salt aleatorio)
‚úÖ Resistente a falsificaci√≥n
‚úÖ Resistente a ataques de colisi√≥n de hash
‚úÖ Seguridad demostrable

Uso: Firmas modernas, TLS 1.3, certificados
Ejemplo: RSA-PSS-SHA256 con salt de 32 bytes</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>Tama√±os de Clave [1,2,10]</h5>
                    <div class="code-example">
                        <pre><strong>Recomendaciones por a√±o:</strong>

RSA-1024: ‚ùå ROTO (2010)
  Factorizado experimentalmente
  No usar bajo ninguna circunstancia

RSA-2048: ‚úÖ Seguro hasta ~2030
  M√≠nimo actual para uso general
  ~112 bits de seguridad equivalente

RSA-3072: ‚úÖ Seguro hasta ~2040
  Recomendado para datos a largo plazo
  ~128 bits de seguridad equivalente

RSA-4096: ‚úÖ Seguro a largo plazo
  Para secretos extremadamente sensibles
  ~140 bits de seguridad equivalente
  M√°s lento (2-4x que RSA-2048)

<strong>Amenaza cu√°ntica:</strong>
Algoritmo de Shor (cu√°ntica) rompe RSA en tiempo
polinomial. Migrar a post-cu√°ntico cuando disponible.</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>Limitaciones de RSA [1,2,10]</h5>
                    <ul>
                        <li><strong>Tama√±o de mensaje:</strong> Solo puede cifrar datos < n (ej: 256 bytes para
                                RSA-2048)</li>
                        <li><strong>Velocidad:</strong> 100-1000√ó m√°s lento que AES</li>
                        <li><strong>Tama√±o de clave:</strong> Claves grandes (2048-4096 bits)</li>
                        <li><strong>Soluci√≥n com√∫n:</strong> Cifrado h√≠brido
                            <div class="code-example">
                                <pre>1. Generar clave AES aleatoria (256 bits)
2. Cifrar datos con AES-256-GCM (r√°pido)
3. Cifrar clave AES con RSA-OAEP (peque√±o)
4. Enviar: RSA(clave_AES) + AES(datos)

Usado en: PGP, S/MIME, TLS handshake</pre>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="best-practices">
                <h4>üõ°Ô∏è Mejores Pr√°cticas RSA [1,2,9,10]</h4>
                <ul>
                    <li>‚úÖ M√≠nimo <strong>RSA-2048</strong>, preferible <strong>RSA-3072</strong> o
                        <strong>RSA-4096</strong>
                    </li>
                    <li>‚úÖ Usa <strong>RSA-OAEP</strong> para cifrado (con SHA-256 o superior)</li>
                    <li>‚úÖ Usa <strong>RSA-PSS</strong> para firmas digitales</li>
                    <li>‚úÖ Genera claves con RNG criptogr√°ficamente seguro</li>
                    <li>‚úÖ Protege clave privada con contrase√±a fuerte</li>
                    <li>‚úÖ Almacena clave privada en hardware (HSM, TPM, YubiKey) si es posible</li>
                    <li>‚úÖ Usa certificados X.509 para vincular clave p√∫blica con identidad</li>
                    <li>‚úÖ Rota claves cada 1-2 a√±os (o seg√∫n pol√≠tica)</li>
                    <li>‚úÖ Considera <strong>ECC (ECDSA/ECDH)</strong> como alternativa m√°s eficiente</li>
                    <li>‚ùå Nunca uses RSA textbook (sin padding)</li>
                    <li>‚ùå No uses RSA-1024 (roto desde 2010)</li>
                    <li>‚ùå No firmes datos sin hashear primero</li>
                    <li>‚ö†Ô∏è Prepara migraci√≥n a criptograf√≠a post-cu√°ntica</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- SHA-256 y Funciones Hash -->
    <div class="demo-section algorithm-expanded">
        <h3>SHA-256 y funciones hash criptogr√°ficas [1,2,11]</h3>

        <div class="algo-info">
            <h4>üìú Historia</h4>
            <p>Las funciones hash han evolucionado a medida que las anteriores fueron rotas [1,2]:</p>
            <ul>
                <li><strong>1989:</strong> MD2 (Message Digest 2) por Ronald Rivest</li>
                <li><strong>1990:</strong> MD4 - M√°s r√°pido, pero d√©bil</li>
                <li><strong>1991:</strong> MD5 - Ampliamente usado, pero <strong>ROTO en 2004</strong> (colisiones)
                </li>
                <li><strong>1995:</strong> SHA-0 (Secure Hash Algorithm) por NSA - Retirado inmediatamente</li>
                <li><strong>1995:</strong> SHA-1 - Reemplazo de SHA-0, <strong>ROTO en 2017</strong> (Google
                    encontr√≥ colisi√≥n)</li>
                <li><strong>2001:</strong> <strong>SHA-2 familia</strong> (SHA-224, SHA-256, SHA-384, SHA-512) -
                    Est√°ndar actual</li>
                <li><strong>2015:</strong> <strong>SHA-3 (Keccak)</strong> - Ganador competencia NIST, dise√±o
                    completamente diferente</li>
                <li><strong>Presente:</strong> SHA-256 en Bitcoin, certificados SSL, integridad de archivos</li>
            </ul>

            <h4>‚öôÔ∏è Funcionamiento interno de SHA-256 [1,2,11]</h4>
            <p>SHA-256 convierte cualquier entrada en una salida de <strong>256 bits (32 bytes / 64 caracteres
                    hexadecimales)</strong>
                de forma determin√≠stica pero aparentemente aleatoria.</p>

            <div class="internal-process">
                <h5>Propiedades fundamentales [1,2,11]:</h5>
                <ol>
                    <li><strong>Determin√≠stico:</strong>
                        <div class="code-example">
                            <pre>Misma entrada ‚Üí Siempre mismo hash
SHA-256("Hola") = 3d5e60...a8f2  (siempre)
SHA-256("Hola") = 3d5e60...a8f2  (nunca cambia)</pre>
                        </div>
                    </li>
                    <li><strong>Efecto Avalancha:</strong>
                        <div class="code-example">
                            <pre>Cambio m√≠nimo ‚Üí Hash completamente diferente
SHA-256("Hola")  = 3d5e60b8a8f2...
SHA-256("Hola!") = 7f9a2b3c8d1e...
                      ‚Üë Un car√°cter cambia TODO</pre>
                        </div>
                    </li>
                    <li><strong>Unidireccional (Preimage Resistance):</strong>
                        <div class="code-example">
                            <pre>Dado hash h, computacionalmente imposible encontrar m
donde SHA-256(m) = h

Complejidad: 2^256 intentos (n√∫mero de √°tomos en universo)</pre>
                        </div>
                    </li>
                    <li><strong>Resistencia a Colisiones:</strong>
                        <div class="code-example">
                            <pre>Computacionalmente imposible encontrar m1 ‚â† m2
donde SHA-256(m1) = SHA-256(m2)

Complejidad: 2^128 intentos (paradoja cumplea√±os)
A√∫n as√≠: 340,282,366,920,938,463,463,374,607,431,768,211,456</pre>
                        </div>
                    </li>
                </ol>

                <h5>Proceso interno de SHA-256 [1,2,11]:</h5>
                <ol>
                    <li><strong>Padding (Relleno):</strong>
                        <div class="code-example">
                            <pre>1. Agregar bit '1' al final del mensaje
2. Agregar bits '0' hasta que longitud ‚â° 448 (mod 512)
3. Agregar longitud original del mensaje (64 bits)

Ejemplo: "abc" (24 bits)
‚Üí "abc" + '1' + 423 ceros + '11000' (24 en binario)
‚Üí Total: 512 bits (un bloque)</pre>
                        </div>
                    </li>
                    <li><strong>Dividir en Bloques de 512 bits:</strong>
                        <div class="code-example">
                            <pre>Mensaje padded ‚Üí Bloques B1, B2, B3, ...
Cada bloque se procesa secuencialmente</pre>
                        </div>
                    </li>
                    <li><strong>Inicializar Estado (8 valores de 32 bits):</strong>
                        <div class="code-example">
                            <pre>H0 = 0x6a09e667  ‚Üê Ra√≠ces cuadradas de primos
H1 = 0xbb67ae85     (fractional parts)
H2 = 0x3c6ef372
H3 = 0xa54ff53a
H4 = 0x510e527f
H5 = 0x9b05688c
H6 = 0x1f83d9ab
H7 = 0x5be0cd19</pre>
                        </div>
                    </li>
                    <li><strong>Procesar Cada Bloque (64 rondas):</strong>
                        <div class="code-example">
                            <pre>Para cada bloque:
  1. Dividir en 16 palabras de 32 bits (W[0..15])
  2. Extender a 64 palabras (W[16..63]) usando rotaciones
  3. Ejecutar 64 rondas de compresi√≥n:
     - Funciones l√≥gicas (AND, OR, XOR, NOT, ROT)
     - Constantes K[i] (ra√≠ces c√∫bicas de primos)
     - Mezclar con estado actual
  4. Actualizar estado H0-H7

Operaciones principales:
Ch(x,y,z)  = (x AND y) XOR (NOT x AND z)
Maj(x,y,z) = (x AND y) XOR (x AND z) XOR (y AND z)
Œ£0(x) = ROTR(2,x) XOR ROTR(13,x) XOR ROTR(22,x)
Œ£1(x) = ROTR(6,x) XOR ROTR(11,x) XOR ROTR(25,x)
œÉ0(x) = ROTR(7,x) XOR ROTR(18,x) XOR SHR(3,x)
œÉ1(x) = ROTR(17,x) XOR ROTR(19,x) XOR SHR(10,x)</pre>
                        </div>
                    </li>
                    <li><strong>Salida Final:</strong>
                        <div class="code-example">
                            <pre>Concatenar H0 || H1 || H2 || H3 || H4 || H5 || H6 || H7
= 256 bits = 32 bytes = 64 caracteres hexadecimales

Ejemplo salida:
2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae</pre>
                        </div>
                    </li>
                </ol>
            </div>

            <h4>Familia SHA-2 y variantes</h4>
            <div class="modes-grid">
                <div class="mode-card">
                    <h5>SHA-224 [1,2,11]</h5>
                    <div class="code-example">
                        <pre><strong>Salida:</strong> 224 bits (28 bytes, 56 hex)
<strong>Bloques:</strong> 512 bits
<strong>Seguridad:</strong> ~112 bits

Uso: Menor que SHA-256, poco com√∫n
Igual que SHA-256 pero truncado</pre>
                    </div>
                </div>

                <div class="mode-card" style="border-color: #4caf50; background: #f1f8f4;">
                    <h5>SHA-256 [1,2,11]</h5>
                    <p><strong>‚úÖ‚úÖ M√ÅS USADO</strong></p>
                    <div class="code-example">
                        <pre><strong>Salida:</strong> 256 bits (32 bytes, 64 hex)
<strong>Bloques:</strong> 512 bits
<strong>Rondas:</strong> 64
<strong>Seguridad:</strong> ~128 bits (colisi√≥n), ~256 bits (preimage)

‚úÖ Est√°ndar actual de la industria
‚úÖ Bitcoin mining (doble SHA-256)
‚úÖ Certificados SSL/TLS
‚úÖ Git commits
‚úÖ Firma de software

Ejemplo salida:
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>SHA-384 [1,2,11]</h5>
                    <div class="code-example">
                        <pre><strong>Salida:</strong> 384 bits (48 bytes, 96 hex)
<strong>Bloques:</strong> 1024 bits
<strong>Seguridad:</strong> ~192 bits

Uso: Intermedio, menos com√∫n que SHA-256/512
Variante truncada de SHA-512</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>SHA-512 [2,11]</h5>
                    <div class="code-example">
                        <pre><strong>Salida:</strong> 512 bits (64 bytes, 128 hex)
<strong>Bloques:</strong> 1024 bits
<strong>Rondas:</strong> 80
<strong>Palabras:</strong> 64 bits (vs 32 en SHA-256)
<strong>Seguridad:</strong> ~256 bits (colisi√≥n), ~512 bits (preimage)

‚úÖ M√°s seguro que SHA-256
‚úÖ M√°s r√°pido en CPUs de 64 bits
‚úÖ Usado en aplicaciones de alta seguridad

Variantes:
- SHA-512/224: Truncado a 224 bits
- SHA-512/256: Truncado a 256 bits (diferente a SHA-256)</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>SHA-3 (Keccak) [11]</h5>
                    <div class="code-example">
                        <pre><strong>Dise√±o:</strong> Construcci√≥n esponja (completamente diferente)
<strong>Salidas:</strong> SHA3-224, SHA3-256, SHA3-384, SHA3-512
<strong>Adicionales:</strong> SHAKE128, SHAKE256 (salida variable)

‚úÖ No relacionado con SHA-2 (dise√±o independiente)
‚úÖ Resistente a ataques de extensi√≥n de longitud
‚úÖ M√°s flexible (SHAKE permite cualquier longitud)
‚ö†Ô∏è Menos adoptado que SHA-256 (por ahora)

Uso: Ethereum (Keccak-256), NIST backup para SHA-2</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>BLAKE2 / BLAKE3 [2,11]</h5>
                    <div class="code-example">
                        <pre><strong>BLAKE2b:</strong> Hasta 512 bits, m√°s r√°pido que SHA-2
<strong>BLAKE2s:</strong> Hasta 256 bits, optimizado para 32-bit
<strong>BLAKE3:</strong> Siguiente generaci√≥n (2020)

‚úÖ M√°s r√°pido que SHA-2 (comparable a MD5)
‚úÖ Tan seguro como SHA-3
‚úÖ Soporta claves (PRF/MAC)
‚úÖ Paralelizable

Uso: Argon2, WireGuard, Zcash, almacenamiento de archivos</pre>
                    </div>
                </div>
            </div>

            <h4>Usos espec√≠ficos de hash</h4>
            <div class="modes-grid">
                <div class="mode-card">
                    <h5>Almacenamiento de contrase√±as [1-3,11]</h5>
                    <p><strong>‚ùå NO usar SHA-256 directo</strong></p>
                    <div class="code-example">
                        <pre>Problema: SHA-256 es demasiado R√ÅPIDO
‚Üí Ataque de diccionario: millones de intentos/segundo

<strong>‚úÖ Soluci√≥n: KDF (Key Derivation Functions)</strong>

<strong>bcrypt:</strong>
- Basado en Blowfish
- Ajustable en costo (factor de trabajo)
- Resistente a GPU/ASIC
bcrypt("password", rounds=12, salt=random)

<strong>scrypt:</strong>
- Requiere mucha memoria (anti-ASIC)
- Usado en Litecoin
scrypt("password", N=16384, r=8, p=1, salt=random)

<strong>Argon2:</strong> ‚úÖ‚úÖ MEJOR ACTUAL (2015)
- Ganador Password Hashing Competition
- Resistente a GPU/ASIC/timing
- Tres variantes: Argon2d, Argon2i, Argon2id
Argon2id("password", time=3, memory=65536, salt=random)

<strong>PBKDF2:</strong>
- Iteraciones m√∫ltiples (100,000+)
- Compatible (TLS, WiFi)
PBKDF2-HMAC-SHA256("password", iterations=100000, salt)</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>HMAC - Hash-based Message Authentication [11]</h5>
                    <div class="code-example">
                        <pre><strong>HMAC-SHA256(clave, mensaje)</strong>

Combina hash con clave secreta
Proporciona autenticaci√≥n e integridad

Proceso:
1. ipad = 0x36 repetido 64 veces
2. opad = 0x5c repetido 64 veces
3. HMAC = H((K XOR opad) || H((K XOR ipad) || mensaje))

‚úÖ Verificar integridad de API requests
‚úÖ JWT (JSON Web Tokens)
‚úÖ Cookies firmadas
‚úÖ Webhooks

Ejemplo:
HMAC-SHA256("secretkey", "datos importantes")
‚Üí b5a8c... (256 bits)

Verificaci√≥n: Recalcular y comparar en tiempo constante</pre>
                    </div>
                </div>

                <div class="mode-card">
                    <h5>Merkle Trees (√Årboles Hash)</h5>
                    <div class="code-example">
                        <pre>Estructura para verificar integridad de grandes conjuntos

        Root Hash
       /         \
    H(AB)       H(CD)
    /  \        /  \
  H(A) H(B)  H(C) H(D)
   |    |     |    |
   A    B     C    D

Propiedades:
‚úÖ Verificar un dato: solo log(n) hashes
‚úÖ Cambio en hoja ‚Üí cambia root
‚úÖ Proof compacta

Uso:
- Bitcoin/Blockchain (verificar transacciones)
- Git (commits)
- BitTorrent (verificar piezas)
- Certificate Transparency
- IPFS (sistema de archivos distribuido)</pre>
                    </div>
                </div>
            </div>

            <div class="best-practices">
                <h4>üõ°Ô∏è Mejores Pr√°cticas con Hash [1-3,11]</h4>
                <ul>
                    <li>‚úÖ Usa <strong>SHA-256</strong> o superior para integridad general</li>
                    <li>‚úÖ Usa <strong>Argon2id</strong> para almacenar contrase√±as (o bcrypt si no disponible)</li>
                    <li>‚úÖ Usa <strong>HMAC-SHA256</strong> para autenticaci√≥n de mensajes</li>
                    <li>‚úÖ Siempre usa <strong>salt √∫nico aleatorio</strong> por usuario (16+ bytes)</li>
                    <li>‚úÖ Usa <strong>pepper</strong> global almacenado fuera de DB (opcional, extra seguridad)</li>
                    <li>‚úÖ Compara hashes en <strong>tiempo constante</strong> (evitar timing attacks)</li>
                    <li>‚úÖ Para archivos grandes, usa <strong>streaming hash</strong> (no cargar todo en memoria)
                    </li>
                    <li>‚ùå NUNCA uses MD5 o SHA-1 para seguridad (solo checksums no cr√≠ticos)</li>
                    <li>‚ùå NUNCA hashees contrase√±as sin salt</li>
                    <li>‚ùå NUNCA uses SHA-256 directo para contrase√±as (demasiado r√°pido)</li>
                    <li>‚ùå NUNCA trunces hashes (usar SHA-224 en vez de truncar SHA-256)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="comparison-table">
        <h3>Comparaci√≥n de Algoritmos [1-3,7-11]</h3>
        <table>
            <thead>
                <tr>
                    <th>Algoritmo</th>
                    <th>Tipo</th>
                    <th>Velocidad</th>
                    <th>Uso Principal</th>
                    <th>Fortaleza</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>AES-256</strong></td>
                    <td>Sim√©trico</td>
                    <td>‚ö° Muy r√°pido</td>
                    <td>Cifrado de datos</td>
                    <td>üü¢ Muy fuerte</td>
                </tr>
                <tr>
                    <td><strong>RSA-2048</strong></td>
                    <td>Asim√©trico</td>
                    <td>üêå Lento</td>
                    <td>Intercambio de claves</td>
                    <td>üü¢ Fuerte</td>
                </tr>
                <tr>
                    <td><strong>ChaCha20</strong></td>
                    <td>Sim√©trico</td>
                    <td>‚ö° Muy r√°pido</td>
                    <td>Mobile, TLS</td>
                    <td>üü¢ Muy fuerte</td>
                </tr>
                <tr>
                    <td><strong>SHA-256</strong></td>
                    <td>Hash</td>
                    <td>‚ö° R√°pido</td>
                    <td>Integridad</td>
                    <td>üü¢ Fuerte</td>
                </tr>
                <tr>
                    <td><strong>bcrypt</strong></td>
                    <td>Hash</td>
                    <td>üêå Lento (a prop√≥sito)</td>
                    <td>Contrase√±as</td>
                    <td>üü¢ Muy fuerte</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="info-box">
        <h4>Cu√°ndo usar cada uno </h4>
        <ul>
            <li><strong>AES:</strong> Cifrar archivos grandes, bases de datos, comunicaciones en tiempo real</li>
            <li><strong>RSA:</strong> Establecer conexi√≥n segura inicial, firmar documentos digitalmente</li>
            <li><strong>SHA-256:</strong> Verificar integridad de archivos, blockchain, tokens</li>
            <li><strong>bcrypt/Argon2:</strong> Almacenar contrase√±as en bases de datos</li>
            <li><strong>Hybrid (RSA + AES):</strong> HTTPS usa RSA para intercambiar clave AES, luego AES para datos
            </li>
        </ul>
    </div>

    <div class="info-box" style="background: #ffebee; border-left-color: #f44336;">
        <h2 style="color: #d32f2f; margin-top: 0;">üí• C√≥mo se Rompen los Cifrados</h2>
        <p>Los algoritmos criptogr√°ficos pueden ser vulnerables a diferentes tipos de ataques.
            Conocer estos ataques es esencial para implementar seguridad correctamente.</p>
    </div>

    <div class="demo-container">
        <div class="demo-section attack-section">
            <h3>üî® Ataque de Fuerza Bruta</h3>
            <div class="algo-info">
                <p><strong>Probar todas las claves posibles</strong></p>
                <div class="attack-demo">
                    <div class="demo-interactive">
                        <label>Simular ataque de fuerza bruta (PIN de 6 d√≠gitos num√©ricos):</label>
                        <input type="text" id="brute-target" placeholder="Ingresa un PIN de 6 d√≠gitos" maxlength="6"
                            pattern="[0-9]{6}" inputmode="numeric" />
                        <button id="brute-attack" class="btn-attack">Iniciar Ataque de Fuerza Bruta</button>
                        <div id="brute-result" class="attack-result"></div>
                    </div>
                    <div class="code-example" style="margin-top: 15px;">
                        <strong>Espacio de claves para PIN num√©rico de 6 d√≠gitos:</strong>
                        <pre>
Posibilidades: 10^6 = 1,000,000 combinaciones (000000 - 999999)

Con 10,000 intentos/segundo:
Tiempo m√°ximo: 100 segundos (1.67 minutos) ‚ùå MUY D√âBIL

Conclusi√≥n: Los PINs cortos son extremadamente vulnerables
                        </pre>
                    </div>
                    <p><strong>Tiempo para romper (con 1 bill√≥n intentos/seg):</strong></p>
                    <ul>
                        <li>6 d√≠gitos num√©ricos: &lt;1 segundo ‚ùå Extremadamente d√©bil</li>
                        <li>40-bit: 18 minutos ‚ùå Muy d√©bil</li>
                        <li>56-bit (DES): 1 d√≠a ‚ùå Roto</li>
                        <li>64-bit: 584 a√±os ‚ö†Ô∏è D√©bil</li>
                        <li>128-bit (AES): 10^18 a√±os ‚úÖ Seguro</li>
                        <li>256-bit (AES): 10^51 a√±os ‚úÖ Muy seguro</li>
                    </ul>
                    <div class="code-example"
                        style="margin-top: 15px; background: #e8f5e9; border-left-color: #4caf50;">
                        <strong>Recursos y Herramientas de Fuerza Bruta:</strong>
                        <ul style="margin: 8px 0; padding-left: 20px; font-size: 0.9em;">
                            <li><a href="https://www.openwall.com/john/" target="_blank" style="color: #2e7d32;">John
                                    the Ripper</a> - Herramienta de password cracking (Open Source)</li>
                            <li><a href="https://hashcat.net/hashcat/" target="_blank"
                                    style="color: #2e7d32;">Hashcat</a> - Password recovery avanzado con GPU</li>
                            <li><a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank"
                                    style="color: #2e7d32;">THC Hydra</a> - Network login cracker</li>
                            <li><a href="https://www.kali.org/tools/crunch/" target="_blank"
                                    style="color: #2e7d32;">Crunch</a> - Generador de wordlists para ataques</li>
                            <li><a href="https://www.grc.com/haystack.htm" target="_blank" style="color: #2e7d32;">GRC
                                    Password Strength</a> - Calculadora de fuerza bruta</li>
                        </ul>
                        <p style="margin: 8px 0; font-size: 0.85em; color: #f57c00;">‚ö†Ô∏è <strong>Uso educativo y pruebas
                                autorizadas √∫nicamente.</strong></p>
                    </div>
                </div>
            </div>
        </div>

        <div class="demo-section attack-section">
            <h3>An√°lisis de Frecuencia</h3>
            <div class="algo-info">
                <p><strong>Explotar patrones en el texto</strong></p>
                <div class="attack-demo">
                    <p>Funciona contra cifrados cl√°sicos d√©biles (C√©sar, Vigen√®re)</p>
                    <div class="code-example">
                        <strong>Ejemplo:</strong>
                        <pre>
Texto cifrado: "KROOR ZRUOG"
‚Üì
Analizar frecuencia de letras
‚Üì
'R' aparece 4 veces ‚Üí probablemente 'O' (letra m√°s com√∫n)
'K' aparece 1 vez ‚Üí probablemente 'H'
‚Üì
Descifrado: "HELLO WORLD" ‚úÖ

Defensa: Usar cifrados modernos (AES) que rompen patrones
                        </pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="demo-section attack-section">
            <h3>Ataque de Diccionario</h3>
            <div class="algo-info">
                <p><strong>Probar contrase√±as comunes primero</strong></p>
                <div class="attack-demo">
                    <p>Efectivo contra contrase√±as d√©biles. Este ataque prueba las 100 contrase√±as m√°s comunes.</p>
                    <div class="demo-interactive">
                        <label>Simular ataque de diccionario:</label>
                        <input type="text" id="dict-target" placeholder="Ingresa una contrase√±a" />
                        <button id="dict-attack" class="btn-attack">Iniciar Ataque</button>
                        <div id="dict-result" class="attack-result"></div>
                    </div>
                    <div class="code-example" style="margin-top: 15px;">
                        <strong>Contrase√±as comunes que probar√°:</strong>
                        <pre style="max-height: 150px; overflow-y: auto;">
password, 123456, 12345678, qwerty, abc123, monkey, 
letmein, trustno1, dragon, baseball, iloveyou, master,
sunshine, ashley, bailey, shadow, superman, admin...

‚úÖ Defensa: Usa contrase√±as largas y √∫nicas
‚úÖ Evita palabras del diccionario
‚úÖ Combina may√∫sculas, min√∫sculas, n√∫meros y s√≠mbolos
                        </pre>
                    </div>
                    <div class="code-example"
                        style="margin-top: 15px; background: #fff3e0; border-left-color: #ff9800;">
                        <strong>Recursos y Diccionarios de Contrase√±as:</strong>
                        <ul style="margin: 8px 0; padding-left: 20px; font-size: 0.9em;">
                            <li><a href="https://github.com/danielmiessler/SecLists" target="_blank"
                                    style="color: #e65100;">SecLists</a> - Colecci√≥n masiva de listas (usernames,
                                passwords, URLs, patterns)</li>
                            <li><a href="https://github.com/berzerk0/Probable-Wordlists" target="_blank"
                                    style="color: #e65100;">Probable-Wordlists</a> - Listas optimizadas por probabilidad
                            </li>
                            <li><a href="https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm"
                                    target="_blank" style="color: #e65100;">CrackStation Wordlist</a> - 15GB de
                                contrase√±as reales filtradas</li>
                            <li><a href="https://github.com/brannondorsey/naive-hashcat" target="_blank"
                                    style="color: #e65100;">Naive Hashcat</a> - Ejemplos de ataques de diccionario</li>
                            <li><a href="https://haveibeenpwned.com/Passwords" target="_blank"
                                    style="color: #e65100;">Have I Been Pwned</a> - 613M+ contrase√±as comprometidas</li>
                        </ul>
                        <p style="margin: 8px 0; font-size: 0.85em; color: #f57c00;">‚ö†Ô∏è <strong>Solo para auditor√≠as
                                autorizadas y prop√≥sitos educativos.</strong></p>
                    </div>
                </div>
            </div>
        </div>

        <div class="demo-section attack-section">
            <h3>üåà Rainbow Tables</h3>
            <div class="algo-info">
                <p><strong>Tablas precalculadas de hashes</strong></p>
                <div class="attack-demo">
                    <div class="code-example">
                        <strong>Concepto:</strong>
                        <pre>
Hash almacenado: 5f4dcc3b5aa765d61d8327deb882cf99
‚Üì
Buscar en rainbow table
‚Üì
Encontrado: "password" ‚úÖ

Defensa: Usar SALT (dato aleatorio √∫nico por usuario)
password + salt ‚Üí hash diferente cada vez
                        </pre>
                    </div>
                    <p><strong>Tama√±o de Rainbow Tables:</strong></p>
                    <ul>
                        <li>MD5 (sin salt): ~150 GB para 8 caracteres</li>
                        <li>SHA-1 (sin salt): ~300 GB para 8 caracteres</li>
                        <li>Con salt √∫nico: ‚àû GB (inviable) ‚úÖ</li>
                    </ul>
                    <div class="code-example" style="margin-top: 15px; background: #e3f2fd;">
                        <strong>üì• Descargar Rainbow Tables:</strong>
                        <p style="margin: 8px 0;">Las rainbow tables son enormes (varios GB). Aqu√≠ hay recursos
                            leg√≠timos para investigaci√≥n:</p>
                        <ul style="margin: 5px 0; padding-left: 20px; font-size: 0.9em;">
                            <li><a href="https://project-rainbowcrack.com/table.htm" target="_blank"
                                    style="color: #1976d2;">RainbowCrack Project</a> - Tablas MD5, SHA-1, NTLM</li>
                            <li><a href="https://freerainbowtables.com/" target="_blank" style="color: #1976d2;">Free
                                    Rainbow Tables</a> - Tablas gratuitas para investigaci√≥n</li>
                            <li><a href="https://ophcrack.sourceforge.io/" target="_blank"
                                    style="color: #1976d2;">Ophcrack</a> - Cracking de Windows con rainbow tables</li>
                            <li><a href="https://crackstation.net/" target="_blank"
                                    style="color: #1976d2;">CrackStation</a> - Lookup online de hashes (15 billion
                                entries)</li>
                        </ul>
                        <p style="margin: 8px 0; font-size: 0.85em; color: #d32f2f;">‚ö†Ô∏è <strong>Solo para prop√≥sitos
                                educativos y de investigaci√≥n.</strong></p>
                    </div>
                </div>
            </div>
        </div>

        <div class="demo-section attack-section">
            <h3>‚è±Ô∏è Timing Attacks</h3>
            <div class="algo-info">
                <p><strong>Medir tiempo de ejecuci√≥n para extraer informaci√≥n</strong></p>
                <div class="attack-demo">
                    <div class="code-example">
                        <strong>Ejemplo vulnerable:</strong>
                        <pre>
// Comparaci√≥n insegura de contrase√±as
function comparePassword(input, real) {
    for (let i = 0; i < input.length; i++) {
        if (input[i] !== real[i]) return false; // ‚ö†Ô∏è Sale temprano
    }
    return true;
}

Ataque: Medir tiempo de respuesta
- "a..." ‚Üí 1 ms (falla en primer car√°cter)
- "p..." ‚Üí 2 ms (falla en segundo car√°cter) ‚Üê ¬°Correcto!
- "pa.." ‚Üí 3 ms (falla en tercer car√°cter) ‚Üê ¬°Correcto!

Defensa: Comparaci√≥n en tiempo constante
                        </pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="demo-section attack-section">
            <h3>üîç Side-Channel Attacks</h3>
            <div class="algo-info">
                <p><strong>Explotar informaci√≥n f√≠sica del sistema</strong></p>
                <div class="attack-demo">
                    <p><strong>Tipos de ataques de canal lateral:</strong></p>
                    <ul>
                        <li><strong>Consumo de energ√≠a:</strong> Analizar fluctuaciones el√©ctricas durante cifrado</li>
                        <li><strong>Radiaci√≥n electromagn√©tica:</strong> Capturar emisiones del hardware</li>
                        <li><strong>Sonido:</strong> An√°lisis ac√∫stico de teclas o procesadores</li>
                        <li><strong>Cach√©:</strong> Meltdown/Spectre explotan cach√© de CPU</li>
                    </ul>
                    <div class="code-example">
                        <strong>Defensa:</strong>
                        <pre>
‚úÖ Hardware resistente a tampering
‚úÖ Implementaciones en tiempo constante
‚úÖ Aleatorizaci√≥n de operaciones
‚úÖ Aislamiento de procesos cr√≠ticos
                        </pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="demo-section attack-section" style="background: #e1f5fe; border-color: #03a9f4;">
            <h3>üñ•Ô∏è Computaci√≥n Cu√°ntica [3,4]</h3>
            <div class="algo-info">
                <p><strong>La amenaza futura m√°s grande</strong></p>
                <div class="attack-demo">
                    <p><strong>Algoritmo de Shor (Computadora Cu√°ntica):</strong></p>
                    <ul>
                        <li>RSA-2048: Rompible en minutos/horas ‚ùå</li>
                        <li>ECC: Rompible en minutos/horas ‚ùå</li>
                        <li>AES-128: Reducido a 64-bit equivalente ‚ö†Ô∏è</li>
                        <li>AES-256: Reducido a 128-bit equivalente ‚úÖ</li>
                    </ul>
                    <div class="code-example">
                        <strong>Criptograf√≠a Post-Cu√°ntica:</strong>
                        <pre>
Algoritmos resistentes a computadoras cu√°nticas:

‚úÖ Lattice-based: CRYSTALS-Kyber, NTRU
‚úÖ Hash-based: SPHINCS+
‚úÖ Code-based: Classic McEliece
‚úÖ Isogeny-based: SIKE

NIST est√° estandarizando estos algoritmos (2024)
                        </pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="info-box" style="background: #e8f5e9; border-left-color: #4caf50;">
        <h4>üõ°Ô∏è Mejores pr√°cticas de defensa</h4>
        <ul>
            <li><strong>Usa algoritmos modernos:</strong> AES-256, RSA-4096, SHA-256, Argon2</li>
            <li><strong>Claves fuertes:</strong> M√≠nimo 128 bits, aleatorias, rotadas peri√≥dicamente</li>
            <li><strong>Siempre usa salt:</strong> √önico por usuario para passwords</li>
            <li><strong>Implementa 2FA:</strong> Incluso si rompen password, necesitan segundo factor</li>
            <li><strong>Actualiza constantemente:</strong> Migra de algoritmos d√©biles (MD5, SHA-1, DES)</li>
            <li><strong>Tiempo constante:</strong> Evita timing attacks en comparaciones</li>
            <li><strong>Prep√°rate para cu√°ntica:</strong> Planea migraci√≥n a post-quantum crypto</li>
            <li><strong>No inventes tu propio crypto:</strong> Usa bibliotecas probadas (OpenSSL, libsodium)</li>
        </ul>
    </div>
</section>

<style>
    .algo-info {
        background: white;
        padding: 12px;
        border-radius: 6px;
    }

    .code-example {
        background: #f5f5f5;
        padding: 12px;
        border-radius: 4px;
        margin-top: 12px;
        border-left: 3px solid #1687a7;
    }

    .code-example pre {
        margin: 8px 0 0 0;
        font-size: 0.85em;
        line-height: 1.5;
        background: none;
        border: none;
        padding: 0;
    }

    .comparison-table {
        margin: 24px 0;
        overflow-x: auto;
    }

    .comparison-table table {
        width: 100%;
        border-collapse: collapse;
        background: white;
        border-radius: 8px;
        overflow: hidden;
    }

    .comparison-table th {
        background: #1687a7;
        color: white;
        padding: 12px;
        text-align: left;
        font-weight: 600;
    }

    .comparison-table td {
        padding: 12px;
        border-bottom: 1px solid #e0e0e0;
    }

    .comparison-table tbody tr:hover {
        background: #f8f9fa;
    }

    .attack-section {
        background: #fff9f0;
        border-left: 4px solid #ff9800;
    }

    .attack-demo {
        margin-top: 12px;
    }

    .demo-interactive {
        background: white;
        padding: 16px;
        border-radius: 6px;
        margin-top: 12px;
    }

    .demo-interactive input {
        width: 100%;
        max-width: 300px;
        margin-bottom: 12px;
    }

    .btn-attack {
        background: #f44336;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1em;
        transition: background 0.2s;
    }

    .btn-attack:hover {
        background: #d32f2f;
    }

    .attack-result {
        margin-top: 16px;
        padding: 12px;
        background: #f5f5f5;
        border-radius: 4px;
        min-height: 50px;
        font-family: monospace;
    }

    /* Estilos para algoritmos expandidos */
    .algorithm-expanded {
        background: white;
        border-left: 4px solid #1687a7;
        margin-bottom: 30px;
    }

    .algorithm-expanded h3 {
        color: #0b3954;
        margin-top: 0;
        padding-bottom: 10px;
        border-bottom: 2px solid #4db8d8;
    }

    .algorithm-expanded h4 {
        color: #1687a7;
        margin-top: 25px;
        margin-bottom: 12px;
        font-size: 1.2em;
    }

    .algorithm-expanded h5 {
        color: #0b3954;
        margin-top: 15px;
        margin-bottom: 10px;
        font-size: 1.05em;
    }

    .internal-process {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin: 15px 0;
    }

    .internal-process ol,
    .internal-process ul {
        margin: 10px 0;
        padding-left: 25px;
    }

    .internal-process li {
        margin: 12px 0;
        line-height: 1.7;
    }

    .modes-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
        margin-top: 15px;
        max-width: 1200px;
    }

    .mode-card {
        background: white;
        border: 2px solid #4db8d8;
        border-radius: 8px;
        padding: 18px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        transition: transform 0.2s, box-shadow 0.2s;
    }

    .mode-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .mode-card h5 {
        color: #0b3954;
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.1em;
        border-bottom: 2px solid #e3f2fd;
        padding-bottom: 8px;
    }

    .mode-card p {
        margin: 8px 0;
        line-height: 1.6;
    }

    .mode-card ul {
        margin: 10px 0;
        padding-left: 20px;
    }

    .mode-card li {
        margin: 8px 0;
        line-height: 1.6;
    }

    .best-practices {
        background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
        border: 2px solid #4caf50;
        border-radius: 10px;
        padding: 20px;
        margin-top: 25px;
    }

    .best-practices h4 {
        color: #2e7d32;
        margin-top: 0;
        margin-bottom: 15px;
    }

    .best-practices ul {
        margin: 10px 0;
        padding-left: 25px;
    }

    .best-practices li {
        margin: 10px 0;
        line-height: 1.7;
    }

    /* Grid de 2 columnas para secci√≥n de ataques */
    .demo-container {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin: 30px 0;
    }

    /* Responsive para algoritmos expandidos */
    @media (max-width: 768px) {
        .algorithm-expanded {
            padding: 15px;
        }

        .internal-process {
            padding: 15px;
        }

        .mode-card {
            padding: 15px;
        }

        .code-example pre {
            font-size: 0.75em;
            overflow-x: auto;
        }

        /* En m√≥vil, 1 columna para las tarjetas de ataque */
        .demo-container {
            grid-template-columns: 1fr;
        }
    }
</style>

<script>
    function setupEncryption() {
        console.log('setupEncryption() ejecut√°ndose...');

        // ===== ATAQUE DE FUERZA BRUTA =====
        const bruteAttackBtn = document.getElementById('brute-attack');
        const bruteTarget = document.getElementById('brute-target');
        const bruteResult = document.getElementById('brute-result');

        console.log('Elementos de fuerza bruta:', {
            btn: bruteAttackBtn,
            target: bruteTarget,
            result: bruteResult
        });

        if (bruteAttackBtn) {
            console.log('Registrando listener para fuerza bruta');
            bruteAttackBtn.addEventListener('click', async () => {
                console.log('Click en bot√≥n de fuerza bruta');
                const target = bruteTarget.value;

                // Validar que sea un PIN de 6 d√≠gitos
                if (!target || !/^\d{6}$/.test(target)) {
                    alert('‚ö†Ô∏è Ingresa un PIN v√°lido de exactamente 6 d√≠gitos num√©ricos');
                    return;
                }

                console.log('Iniciando ataque para PIN:', target);
                bruteAttackBtn.disabled = true;
                bruteResult.innerHTML = '<strong>üî® Iniciando ataque de fuerza bruta...</strong><br><br>';

                let attempts = 0;
                let found = false;
                const startTime = Date.now();
                const maxAttempts = 1000000; // 10^6 posibilidades
                const speedSimulation = 10000; // Simular 10,000 intentos/seg

                // Simular el ataque con intervalos
                for (let pin = 0; pin < maxAttempts && !found; pin++) {
                    attempts++;
                    const currentPin = String(pin).padStart(6, '0');

                    // Actualizar UI cada 5000 intentos
                    if (attempts % 5000 === 0) {
                        const elapsed = (Date.now() - startTime) / 1000;
                        const percentage = ((attempts / maxAttempts) * 100).toFixed(2);
                        bruteResult.innerHTML = `
                            <strong>üî® Probando combinaciones...</strong><br>
                            Intentos: ${attempts.toLocaleString()} / ${maxAttempts.toLocaleString()}<br>
                            Progreso: ${percentage}%<br>
                            √öltimo intento: ${currentPin}<br>
                            Tiempo transcurrido: ${elapsed.toFixed(2)}s<br>
                        `;
                        // Permitir que el navegador actualice la UI
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    // Verificar si encontramos el PIN
                    if (currentPin === target) {
                        found = true;
                        const totalTime = (Date.now() - startTime) / 1000;
                        bruteResult.innerHTML = `
                            <strong style="color: #f44336;">üö® ¬°PIN ENCONTRADO!</strong><br><br>
                            ‚úÖ PIN crackeado: <strong>${currentPin}</strong><br>
                            üìä Intentos necesarios: ${attempts.toLocaleString()}<br>
                            ‚è±Ô∏è Tiempo real: ${totalTime.toFixed(2)} segundos<br>
                            üíª Velocidad simulada: ~${Math.round(attempts / totalTime).toLocaleString()} intentos/seg<br><br>
                            <span style="color: #f44336;">‚ö†Ô∏è CONCLUSI√ìN: Los PINs de 6 d√≠gitos son MUY INSEGUROS</span><br>
                            <span style="font-size: 0.9em;">Un atacante con hardware dedicado podr√≠a probar millones por segundo.</span>
                        `;
                    }
                }

                if (!found) {
                    bruteResult.innerHTML += '<br><strong>‚ùå Error en la simulaci√≥n</strong>';
                }

                bruteAttackBtn.disabled = false;
            });
        } else {
            console.error('No se encontr√≥ el bot√≥n de fuerza bruta');
        }

        // ===== ATAQUE DE DICCIONARIO =====
        const dictAttackBtn = document.getElementById('dict-attack');
        const dictTarget = document.getElementById('dict-target');
        const dictResult = document.getElementById('dict-result');

        console.log('Elementos de diccionario:', {
            btn: dictAttackBtn,
            target: dictTarget,
            result: dictResult
        });

        if (dictAttackBtn) {
            console.log('Registrando listener para diccionario');
            const commonPasswords = [
                'password', '123456', '12345678', 'qwerty', 'abc123',
                'monkey', 'letmein', 'trustno1', 'dragon', 'baseball',
                'iloveyou', 'master', 'sunshine', 'ashley', 'bailey',
                'shadow', 'superman', 'michael', 'welcome', 'password1',
                'admin', 'root', 'pass', '123123', 'password123',
                'qwerty123', 'admin123', 'letmein123', '1234567890', 'password1234',
                'welcome123', 'password12345', 'admin1234', '12345', '123',
                'jordan', 'charlie', 'princess', 'starwars', 'computer',
                'freedom', 'princess', 'qazwsx', 'football', 'liverpool',
                'london', 'jessica', 'daniel', 'jennifer', 'thomas',
                'jordan23', 'zxcvbnm', 'asdfgh', 'Password', 'Password1',
                'Password123', 'Admin', 'Admin123', 'Welcome1', 'Letmein',
                'Qwerty', 'Abc123', 'Monkey1', 'Dragon1', 'Master1',
                'Soccer', 'Love', 'Secret', 'Summer', 'Winter',
                'Spring', 'Autumn', 'Killer', 'Tigger', 'Pepper',
                'Mustang', 'Ranger', 'Batman', 'Spider', 'Ginger',
                'Dallas', 'Matrix', 'Access', 'Flower', 'Silver',
                'Shadow1', 'Buster', 'Dakota', 'Cowboy', 'Prince',
                'Guitar', 'Golfer', 'Rocket', 'Thunder', 'Cookie',
                'Cheese', 'Smokey', 'Hunter', 'Angel', 'Harley'
            ];

            dictAttackBtn.addEventListener('click', () => {
                console.log('Click en bot√≥n de diccionario');
                const target = dictTarget.value;
                console.log('Contrase√±a objetivo:', target);

                if (!target) {
                    alert('‚ö†Ô∏è Ingresa una contrase√±a objetivo');
                    return;
                }

                dictAttackBtn.disabled = true;
                dictResult.innerHTML = '<strong>üéØ Iniciando ataque de diccionario...</strong><br><span style="font-size: 0.9em;">Probando las 100 contrase√±as m√°s comunes...</span><br><br>';

                let attempts = 0;
                let found = false;

                const interval = setInterval(() => {
                    if (attempts >= commonPasswords.length) {
                        dictResult.innerHTML += `<br><strong style="color: #4caf50;">‚úÖ Ataque completado</strong><br>`;
                        dictResult.innerHTML += `üìä Total de intentos: ${attempts}<br>`;
                        dictResult.innerHTML += `‚è±Ô∏è Tiempo estimado: ${(attempts * 0.1).toFixed(1)} segundos<br><br>`;
                        if (!found) {
                            dictResult.innerHTML += `<span style="color: #4caf50;"><strong>üéâ ¬°Tu contrase√±a es m√°s segura!</strong><br>`;
                            dictResult.innerHTML += `No est√° en el diccionario de contrase√±as comunes.</span><br>`;
                            dictResult.innerHTML += `<span style="font-size: 0.85em;">Pero recuerda: diccionarios m√°s grandes tienen millones de entradas.</span>`;
                        }
                        clearInterval(interval);
                        dictAttackBtn.disabled = false;
                        return;
                    }

                    const attempt = commonPasswords[attempts];

                    if (attempt === target) {
                        dictResult.innerHTML = `<strong style="color: #f44336;">üö® ¬°CONTRASE√ëA CRACKEADA!</strong><br><br>`;
                        dictResult.innerHTML += `‚úÖ Contrase√±a encontrada: <strong>"${target}"</strong><br>`;
                        dictResult.innerHTML += `üìä Intentos necesarios: ${attempts + 1}<br>`;
                        dictResult.innerHTML += `‚è±Ô∏è Tiempo de ataque: ${((attempts + 1) * 0.1).toFixed(1)} segundos<br><br>`;
                        dictResult.innerHTML += `<span style="color: #f44336;"><strong>‚ö†Ô∏è PELIGRO: Contrase√±a extremadamente com√∫n</strong><br>`;
                        dictResult.innerHTML += `Esta contrase√±a est√° en el top ${attempts + 1} de las m√°s usadas.<br>`;
                        dictResult.innerHTML += `Cambiarla INMEDIATAMENTE.</span><br><br>`;
                        dictResult.innerHTML += `<strong>Historial del ataque:</strong><br>`;
                        dictResult.innerHTML += `<div style="font-size: 0.85em; max-height: 100px; overflow-y: auto; background: #f5f5f5; padding: 8px; margin-top: 5px;">`;
                        for (let i = 0; i <= attempts; i++) {
                            const mark = i === attempts ? ' ‚Üê ‚úÖ MATCH!' : '';
                            dictResult.innerHTML += `${i + 1}. "${commonPasswords[i]}"${mark}<br>`;
                        }
                        dictResult.innerHTML += `</div>`;
                        found = true;
                        clearInterval(interval);
                        dictAttackBtn.disabled = false;
                    } else if (attempts < 10 || attempts === commonPasswords.length - 1) {
                        // Mostrar solo los primeros 10 intentos y el √∫ltimo
                        dictResult.innerHTML += `${attempts + 1}. Probando "${attempt}" ... ‚ùå<br>`;
                    } else if (attempts === 10) {
                        dictResult.innerHTML += `<span style="font-size: 0.85em; color: #666;">... probando m√°s contrase√±as ...</span><br>`;
                    }

                    attempts++;
                }, 100);
            });
        } else {
            console.error('No se encontr√≥ el bot√≥n de diccionario');
        }

        console.log('setupEncryption() completado');
    }

    // Exportar funci√≥n para que main.js pueda llamarla
    if (typeof window !== 'undefined') {
        window.setupEncryption = setupEncryption;
        console.log('setupEncryption asignada a window');
    }
</script>
<script src="/js/rsa.js"></script>